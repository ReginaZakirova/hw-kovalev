<?php

/* ******************************    Задание 14 - 4    ****************************** */
echo "<br> Задание 14 - 4 <br>";
$n = 10;                // Количество элементов в массиве
$polmin = 101;          // Заведомо зададим искомое минимальное положительное число как ..100] + 1
$negmax = -101;         // Заведомо зададим искомое максимальное отрицательное число как [-100.. - 1
echo "Массив: ";
for ($i = 0; $i < $n; $i++) {
    $arr1[$i] = mt_rand(-100, 100);
    echo "$arr1[$i] ";   // Определение и вывод текущего элемента массива
    /*  Если текущий элемент массива положителен и меньше текущего минимальное положительного, то переопределяем
        значение минимального положительного значением этого элемента массива. */
    if (($arr1[$i] > 0) and ($arr1[$i] < $polmin)) {
        $polmin = $arr1[$i];
    }
    /*  Если текущий элемент массива отрицателен и больше текущего максимального отрицательного, то переопределяем
        значение максимальногоо отрицательного значением этого элемента массива. */
    if (($arr1[$i] < 0) and ($arr1[$i] > $negmax)) {
        $negmax = $arr1[$i];
    }
}
/*  Осталось разобраться с выводом результата - и здесь возможно два варианта:
    1.  Если изначально заданное в программе минимальное положительное 101 так и не изменилось, значит, исходя из
        условий проверки, в массиве отсутствуют какие-либо положительные числа.
    2.  Изначально заданное в программе минимальное положительное 101 было изменено - выводим искомый результат.
    Схожим образом выводим и значение максимального отрицательного элемента массива. */
if ($polmin != 101) {
    echo "<br>Минимальное положительное: $polmin";
}
else {
    echo "<br>Положительных чисел в массиве нет!";
}
if ($negmax != -101) {
    echo "<br>Максимальное отрицательное: $negmax";
}
else {
    echo "<br>Отрицательных чисел в массиве нет!";
}
echo "<br>";
/**************************************************************************************/


/* ******************************    Задание 15 - 5    ****************************** */
echo "<br> Задание 15 - 5 <br>";
/*  Не могу сказать, что точно понял для чего именно нужен ассоциативный массив в приложении к данной задаче!
    С одной стороны возможно я должен объявить ассоциированные индексы (ключи) для фамилий учеников, с другой -
    я решил проассоциировать названия предметов с одномерными массивами содержащими ряд оценок всех учеников по
    каждому предмету. В этом случае значение ключа легко подставлять в строку вывода результата, правда его значение
    написано русскими, а не латинскими буквами, что не есть хорошо! В общем, хотелось бы увидеть правильное решение,
    как его задумал автор задачи! */
$scores = [
    'математика' => [3, 4, 5, 4, 3],
    'физика' => [4, 5, 4, 3, 5],
    'химия' => [5, 4, 3, 3, 4],
    'информатика' => [3, 4, 3, 4, 3]
];
foreach ($scores as $key => $science) {
    $sum = 0;
    foreach ($science as $score) {
        $sum += $score;
    }
    echo "Cумма оценок по предмету $key равна: $sum<br>";
    echo "Cредняя оценка по предмету $key равна:" . $sum / count($science) . "<br>";
}
/**************************************************************************************/

/* ******************************    Задание 15 - 5    ****************************** */
echo "<br> Задание 15 - 6 <br>";
echo "Пока не стал делать, так как есть вопросы к условиям задания - надо прояснить!<br>";
/**************************************************************************************/

/* ******************************    Задание 15 - 5    ****************************** */
echo "<br> Задание 15 - 7 <br>";
define('ROW', 5);               // Зададим константой ROW число строк массива
define('COL', 6);               // Зададим константой COL число столбцов массива
$mul = 1;                       // Зададим начальное значение произведения максимальных элементов четных столбцов
/*  Сгенерируем массив 5x6 из случайных элементов в диапазоне [1 .. 100] и выведем его визуальное представление
    с помощью HTML-тега <pre> для сохранения форматирования символами пустого пространства.
    По условию задания нам придется искать максимальное значение в четных столбцах - и здесь мы приходим
    к вопросу: "А какой именно столбец считать четным? Четным по индексу или четным по счету? Чтобы разрешить этот
    казус я решил воспользоваться возможностью языка PHP начинать индексацию с произвольного числа и уровнять эти
    две категории, задавая индексацию столбцов с 1, а не с 0. */
echo "<pre>";
for ($i = 0; $i < ROW; $i++) {
    for ($j = 1; $j < COL + 1; $j++) {
        $arr4[$i][$j] = mt_rand(1, 100);
        echo $arr4[$i][$j] . "\t";
    }
    echo "<br>";
/*  Забавно, но браузер применяет к тегу <pre> свои стили отличные от всего остального документа!*/
}
echo "</pre>";
/*  Для поиска максимальных значений в четных столбцах организуем внешний цикл обхода индекса столбцов,
    начиная с значения 2 и с шагом 2. Для каждого четного столбца будем значению искомого максимального элемента
    $maxcol присваивать значение элемента первой строки. Во внутреннем цикле обхода индекса строк будем искать
    значение максимального элемента. */
for ($j = 2; $j < COL + 1; $j += 2) {
    $maxcol = $arr4[0][$j];
    for ($i = 1; $i < ROW; $i++) {
        if ($arr4[$i][$j] > $maxcol) {
            $maxcol = $arr4[$i][$j];
        }
    }
    $mul *= $maxcol;            // Переопределяем значение произведения максимальных элементов четных столбцов
    echo "Максимальный элемент в четном столбце $j равен: $maxcol<br>";
}
echo "Произведение максимальных элементов в четных столбцах массива равно: $mul";
/**************************************************************************************/